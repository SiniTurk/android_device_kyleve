diff -ur CM11_loganxx/frameworks/base/services/java/com/android/server/power/PowerManagerService.java CM11_loganxxP/frameworks/base/services/java/com/android/server/power/PowerManagerService.java
--- CM11_loganxx/frameworks/base/services/java/com/android/server/power/PowerManagerService.java	2016-02-19 12:52:22.000000000 +0000
+++ CM11_loganxxP/frameworks/base/services/java/com/android/server/power/PowerManagerService.java	2016-02-22 18:45:44.000000000 +0000
@@ -247,6 +247,7 @@
     // Timestamp of the last call to user activity.
     private long mLastUserActivityTime;
     private long mLastUserActivityTimeNoChangeLights;
+	 private long mLastButtonActivityTime;
 
     // A bitfield that summarizes the effect of the user activity timer.
     // A zero value indicates that the user activity timer has expired.
@@ -1145,6 +1146,10 @@
                 return true;
             }
         } else {
+			 if (eventTime > mLastButtonActivityTime && (event & PowerManager.USER_ACTIVITY_EVENT_BUTTON) != 0) {
+                    mLastButtonActivityTime = eventTime;
+                    mDirty |= DIRTY_USER_ACTIVITY;
+            }
             if (eventTime > mLastUserActivityTime) {
                 mLastUserActivityTime = eventTime;
                 mDirty |= DIRTY_USER_ACTIVITY;
@@ -1735,7 +1740,7 @@
                         }
 
                         mKeyboardLight.setBrightness(mKeyboardVisible ? keyboardBrightness : 0);
-                        if (mButtonTimeout != 0 && now > mLastUserActivityTime + mButtonTimeout) {
+                        if (mButtonTimeout != 0 && now > mLastButtonActivityTime + mButtonTimeout) {
                             mButtonsLight.setBrightness(0);
                         } else {
                             mButtonsLight.setBrightness(buttonBrightness);
@@ -2666,8 +2671,9 @@
         if (reason == null) {
             reason = "";
         }
-        long duration;
-        if (reason.equals(PowerManager.REBOOT_RECOVERY)) {
+		 Log.e(TAG, "Reboot to recovery");
+		 SystemProperties.set("sys.powerctl", "reboot," + reason);
+		 Log.e(TAG, "Reboot to recovery sys.powerctl ok");
             // If we are rebooting to go into recovery, instead of
             // setting sys.powerctl directly we'll start the
             // pre-recovery service which will do some preparation for
@@ -2676,15 +2682,11 @@
             // This preparation can take more than 20 seconds if
             // there's a very large update package, so lengthen the
             // timeout.
-            SystemProperties.set("ctl.start", "pre-recovery");
-            duration = 120 * 1000L;
-        } else {
-            SystemProperties.set("sys.powerctl", "reboot," + reason);
-            duration = 20 * 1000L;
-        }
         try {
-            Thread.sleep(duration);
+			 Log.e(TAG, "Reboot to recovery sleep(20000)");
+		     Thread.sleep(20000);
         } catch (InterruptedException e) {
+			 Log.e(TAG, "Reboot to recovery interrupt");
             Thread.currentThread().interrupt();
         }
     }
diff -ur CM11_loganxx/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java CM11_loganxxP/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java
--- CM11_loganxx/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-19 12:52:22.000000000 +0000
+++ CM11_loganxxP/frameworks/base/telephony/java/android/telephony/MSimTelephonyManager.java	2016-02-22 18:47:57.000000000 +0000
@@ -957,35 +957,11 @@
      * @hide
      */
     public static void setTelephonyProperty(String property, int index, String value) {
-        String propVal = "";
-        String p[] = null;
-        String prop = SystemProperties.get(property);
-
-        if (value == null) {
-            value = "";
-        }
-
-        if (prop != null) {
-            p = prop.split(",");
-        }
-
-        if (index < 0) return;
-
-        for (int i = 0; i < index; i++) {
-            String str = "";
-            if ((p != null) && (i < p.length)) {
-                str = p[i];
-            }
-            propVal = propVal + str + ",";
+        if (index != 0) {
+            property += "_" + index;
         }
 
-        propVal = propVal + value;
-        if (p != null) {
-            for (int i = index+1; i < p.length; i++) {
-                propVal = propVal + "," + p[i];
-            }
-        }
-        SystemProperties.set(property, propVal);
+        SystemProperties.set(property, value);
     }
 
     /**
@@ -994,16 +970,10 @@
      * @hide
      */
     public static String getTelephonyProperty(String property, int index, String defaultVal) {
-        String propVal = null;
-        String prop = SystemProperties.get(property);
-
-        if ((prop != null) && (prop.length() > 0)) {
-            String values[] = prop.split(",");
-            if ((index >= 0) && (index < values.length) && (values[index] != null)) {
-                propVal = values[index];
-            }
+        if (index != 0) {
+            property += "_" + index;
         }
-        return propVal == null ? defaultVal : propVal;
+		 return SystemProperties.get(property, defaultVal);
     }
 
     /**

 status_t SensorEventQueue::flush() const {


diff -ur CM11_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp CM11_loganxxP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
--- CM11_loganxx/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-19 12:52:24.000000000 +0000
+++ CM11_loganxxP/frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp	2016-02-22 18:51:21.000000000 +0000
@@ -1162,6 +1162,7 @@
             sp<const DisplayDevice> hw(mDisplays[dpy]);
             const int32_t id = hw->getHwcDisplayId();
             if (id >= 0) {
+			#ifdef QCOM_HARDWARE
                 // Get the layers in the current drawying state
                 const LayerVector& layers(mDrawingState.layersSortedByZ);
                 bool freezeSurfacePresent = false;
@@ -1181,6 +1182,7 @@
                         }
                     }
                 }
+			#endif
 
                 const Vector< sp<Layer> >& currentLayers(
                     hw->getVisibleLayersSortedByZ());
@@ -1194,6 +1196,7 @@
                      */
                     const sp<Layer>& layer(currentLayers[i]);
                     layer->setPerFrameData(hw, *cur);
+			#ifdef QCOM_HARDWARE		
                     if(freezeSurfacePresent) {
                         // if freezeSurfacePresent, set ANIMATING flag
                         cur->setAnimating(true);
@@ -1218,6 +1221,7 @@
                             lastSurfaceViewLayer = layer;
                         }
                     }
+			#endif
                 }
             }
         }
@@ -3392,6 +3396,11 @@
 {
     ATRACE_CALL();
 
+	// Rotation artifact problems when useReadPixels is false
+	#ifdef HAWAII_HWC
+    useReadPixels = true;
+	#endif
+
     // get screen geometry
     const uint32_t hw_w = hw->getWidth();
     const uint32_t hw_h = hw->getHeight();
diff -ur CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java
--- CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/ExtCallManager.java	2016-02-22 18:54:50.000000000 +0000
@@ -334,6 +334,16 @@
             case RINGING:
                 if (VDBG) Rlog.d(LOG_TAG, "setAudioMode RINGING");
                 int curAudioMode = mAudioManager.getMode();
+				// HACK: When Dual-SIM is enabled and call waiting occurs,
+                // com.android.phone.CallCommandService.setActiveSubscription
+                // will cause setAudioMode to be called, causing the audio
+                // mode to be chagned to "MODE_RINGTONE", rendering the active
+                // conversation to be inaudiable.
+                // (The setAudioMode() call does not occur without Dual-SIM.)
+                if (curAudioMode == AudioManager.MODE_IN_CALL) {
+					Rlog.d(LOG_TAG, "Skip MODE_IN_CALL -> MODE_RINGTONE (assume call waiting)");
+                    return;
+                }
                 if (curAudioMode != AudioManager.MODE_RINGTONE) {
                     // only request audio focus if the ringtone is going to be heard
                     if (mAudioManager.getStreamVolume(AudioManager.STREAM_RING) > 0
diff -ur CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java
--- CM11_loganxx/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony/src/java/com/android/internal/telephony/PhoneBase.java	2016-02-22 18:55:14.000000000 +0000
@@ -150,6 +150,7 @@
     boolean mDnsCheckDisabled;
     public DcTrackerBase mDcTracker;
     boolean mDoesRilSendMultipleCallRing;
+	boolean mDoesRilSendCallRing;
     int mCallRingContinueToken;
     int mCallRingDelay;
     public boolean mIsTheCurrentActivePhone = true;
@@ -329,6 +330,11 @@
                 TelephonyProperties.PROPERTY_RIL_SENDS_MULTIPLE_CALL_RING, true);
         Rlog.d(LOG_TAG, "mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
 
+		 // Some RIL do not even send a single RIL_UNSOL_CALL_RING
+        mDoesRilSendCallRing = SystemProperties.getBoolean(
+                "ro.telephony.call_ring", true);
+        Rlog.d(LOG_TAG, "mDoesRilSendCallRing=" + mDoesRilSendCallRing);
+		
         mCallRingDelay = SystemProperties.getInt(
                 TelephonyProperties.PROPERTY_CALL_RING_DELAY, 3000);
         Rlog.d(LOG_TAG, "mCallRingDelay=" + mCallRingDelay);
@@ -1381,6 +1387,18 @@
     protected void notifyNewRingingConnectionP(Connection cn) {
         if (!mIsVoiceCapable)
             return;
+			
+		 // Fake RIL_UNSOL_CALL_RING if the RIL doesn't send it.
+        // Note that we need the delay to prevent the request from
+        // being sent after CallTracker detects "RINGING" state, but
+        // before the correct contact-specific ringtone is queried.
+        // Otherwise, the incorrect ringtone will be used
+        if (!mDoesRilSendCallRing) {
+            int token = ++mCallRingContinueToken;
+            sendMessageDelayed(
+                    obtainMessage(EVENT_CALL_RING_CONTINUE, token, 0), mCallRingDelay);
+        }
+
         AsyncResult ar = new AsyncResult(null, cn, null);
         mNewRingingConnectionRegistrants.notifyRegistrants(ar);
     }
@@ -1522,6 +1540,7 @@
         pw.println(" mDnsCheckDisabled=" + mDnsCheckDisabled);
         pw.println(" mDcTracker=" + mDcTracker);
         pw.println(" mDoesRilSendMultipleCallRing=" + mDoesRilSendMultipleCallRing);
+		 pw.println(" mDoesRilSendCallRing=" + mDoesRilSendCallRing);
         pw.println(" mCallRingContinueToken=" + mCallRingContinueToken);
         pw.println(" mCallRingDelay=" + mCallRingDelay);
         pw.println(" mIsTheCurrentActivePhone=" + mIsTheCurrentActivePhone);
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/CardSubscriptionManager.java	2016-02-22 18:56:41.000000000 +0000
@@ -143,11 +143,13 @@
 
 
     //***** Events
-    private static final int EVENT_RADIO_NOT_AVAILABLE = 1;
+    private static final int EVENT_RADIO_OFF_OR_NOT_AVAILABLE = 0;
+    private static final int EVENT_RADIO_ON = 1;
     private static final int EVENT_ICC_CHANGED = 2;
     private static final int EVENT_GET_ICCID_DONE = 3;
     private static final int EVENT_UPDATE_UICC_STATUS = 4;
     private static final int EVENT_SIM_REFRESH = 5;
+	 private static final int EVENT_RADIO_NOT_AVAILABLE = 6;
 
     //***** Class Variables
     private static CardSubscriptionManager sCardSubscriptionManager;
@@ -156,6 +158,7 @@
     private CommandsInterface[] mCi;
     private MSimUiccController mUiccController;
     private int mNumPhones = MSimTelephonyManager.getDefault().getPhoneCount();
+	 private boolean[] mRadioOn = new boolean[mNumPhones];
     private boolean[] mSubActivated = new boolean[mNumPhones];
 
     private int mUpdateUiccStatusContext = 0;
@@ -203,10 +206,13 @@
         for (int i = 0; i < mCi.length; i++) {
             // Register for Subscription ready event for both the subscriptions.
             Integer slot = new Integer(i);
+			 mCi[i].registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_NOT_AVAILABLE, slot);
             mCi[i].registerForNotAvailable(this, EVENT_RADIO_NOT_AVAILABLE, slot);
+			 mCi[i].registerForOn(this, EVENT_RADIO_ON, slot);
 
             // Register for SIM Refresh events
             mCi[i].registerForIccRefresh(this, EVENT_SIM_REFRESH, new Integer(i));
+			 mRadioOn[i] = false;
             mSubActivated[i] = false;
         }
 
@@ -231,6 +237,16 @@
     @Override
     public void handleMessage(Message msg) {
         switch(msg.what) {
+			case EVENT_RADIO_OFF_OR_NOT_AVAILABLE:
+                logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE");
+                processRadioOffOrNotAvailable((AsyncResult)msg.obj);
+                break;
+
+            case EVENT_RADIO_ON:
+                logd("EVENT_RADIO_ON");
+                processRadioOn((AsyncResult)msg.obj);
+                break;
+
             case EVENT_RADIO_NOT_AVAILABLE:
                 logd("EVENT_RADIO_NOT_AVAILABLE");
                 processRadioNotAvailable((AsyncResult)msg.obj);
@@ -279,13 +295,36 @@
             loge("processSimRefresh received without input");
         }
     }
+	
+	private void processRadioOffOrNotAvailable(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOffOrNotAvailable on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
+            //If sub is deactivated then reset card info.
+            if (mSubActivated[cardIndex] == false) {
+                resetCardInfo(cardIndex);
+                //CardInfo is not valid. Inform others that card info not available.
+                notifyCardInfoNotAvailable(cardIndex,
+                        CardUnavailableReason.REASON_RADIO_UNAVAILABLE);
+                // Reset the flag card info available to false, so that
+                // next time it notifies all cards info available.
+                mAllCardsInfoAvailable = false;
+            }
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
 
     private void processRadioNotAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
 
         logd("processRadioNotAvailable on cardIndex = " + cardIndex);
 
-        if (cardIndex >= 0 && cardIndex < mNumPhones) {
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = false;
             //Radio unavailable comes in case of rild crash or Modem SSR.
             //reset card info in case of radio Unavailable in order to send SET_UICC later.
             resetCardInfo(cardIndex);
@@ -300,6 +339,18 @@
             logd("Invalid Index!!!");
         }
     }
+	
+	private void processRadioOn(AsyncResult ar) {
+        Integer cardIndex = (Integer)ar.userObj;
+
+        logd("processRadioOn on cardIndex = " + cardIndex);
+
+        if (cardIndex >= 0 && cardIndex < mRadioOn.length) {
+            mRadioOn[cardIndex] = true;
+        } else {
+            logd("Invalid Index!!!");
+        }
+    }
 
     /**
      * Process the ICC_CHANGED notification.
@@ -312,6 +363,10 @@
 
         if ((ar.exception == null) && (ar.result != null)) {
             Integer cardIndex = (Integer) ar.result;
+			if (!mRadioOn[cardIndex]) {
+                logd("handleIccChanged: radio not available - EXIT");
+                return;
+            }
             UiccCard uiccCard = mUiccController.getUiccCards()[cardIndex];
             UiccCard card = mUiccCardList.get(cardIndex).getUiccCard();
 
@@ -450,6 +505,11 @@
         }
 
         logd("handleGetIccIdDone: cardIndex = " + cardIndex);
+		
+		if (!mRadioOn[cardIndex]) {
+            logd("handleGetIccIdDone: radio not available - EXIT");
+            return;
+        }
 
         String iccId = null;
 
@@ -588,7 +648,8 @@
             uiccCard = cardInfo.getUiccCard();
         }
 
-        if (uiccCard == null) {
+        if (uiccCard == null || mRadioOn[cardIndex] == false) {
+            logd("onUpdateUiccStatus(): mRadioOn[" + cardIndex + "] = " + mRadioOn[cardIndex]);
             logd("onUpdateUiccStatus(): NO Card!!!!! at index : " + cardIndex);
             if (mCardSubData[cardIndex] != null) {
                 // Card is removed.
@@ -713,7 +774,7 @@
 
         // Required to notify only once!!!
         // Notify if all card info is available.
-        if (isValidCards() && !mAllCardsInfoAvailable) {
+        if (isValidCards() && !mAllCardsInfoAvailable && mRadioOn[cardIndex]) {
             mAllCardsInfoAvailable = true;
             notifyAllCardsInfoAvailable();
         }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimCDMALTEPhone.java	2016-02-22 18:57:12.000000000 +0000
@@ -99,7 +99,6 @@
                 this, EVENT_SUBSCRIPTION_ACTIVATED, null);
         subMgr.registerForSubscriptionDeactivated(mSubscription,
                 this, EVENT_SUBSCRIPTION_DEACTIVATED, null);
-        mSubscriptionData = subMgr.getCurrentSubscription(mSubscription);
     }
 
     @Override
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimGSMPhone.java	2016-02-22 18:57:23.000000000 +0000
@@ -85,7 +85,6 @@
                 this, EVENT_SUBSCRIPTION_ACTIVATED, null);
         subMgr.registerForSubscriptionDeactivated(mSubscription,
                 this, EVENT_SUBSCRIPTION_DEACTIVATED, null);
-        mSubscriptionData = subMgr.getCurrentSubscription(mSubscription);
 
         setProperties();
     }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/MSimUiccController.java	2016-02-22 18:57:35.000000000 +0000
@@ -157,7 +157,6 @@
             Integer index = new Integer(i);
             mCis[i].registerForIccStatusChanged(this, EVENT_ICC_STATUS_CHANGED, index);
             // TODO remove this once modem correctly notifies the unsols
-            mCis[i].registerForAvailable(this, EVENT_ICC_STATUS_CHANGED, index);
             mCis[i].registerForOn(this, EVENT_ICC_STATUS_CHANGED, index);
             mCis[i].registerForNotAvailable(this, EVENT_RADIO_UNAVAILABLE, index);
         }
diff -ur CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java
--- CM11_loganxx/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-19 12:52:25.000000000 +0000
+++ CM11_loganxxP/frameworks/opt/telephony-msim/frameworks/src/com/codeaurora/telephony/msim/SubscriptionManager.java	2016-02-22 18:58:15.000000000 +0000
@@ -164,6 +164,7 @@
 
     private boolean[] mCardInfoAvailable = new boolean[mNumPhones];
     private boolean[] mIsNewCard = new boolean[mNumPhones];
+	private boolean[] mRadioOn = new boolean[mNumPhones];
 
     private HashMap<SubscriptionId, Subscription> mActivatePending;
     private HashMap<SubscriptionId, Subscription> mDeactivatePending;
@@ -272,6 +273,7 @@
 
             mCardInfoAvailable[i] = false;
             mIsNewCard[i] = false;
+			mRadioOn[i] = false;
         }
 
         mSubDeactivatedRegistrants = new RegistrantList[mNumPhones];
@@ -323,15 +325,21 @@
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_OFF_OR_NOT_AVAILABLE on SUB: " + subId);
-                mSetSubscriptionInProgress = false;
-                mSetDdsRequired = true;
+                mRadioOn[subId] = false;
+                if (!isAllRadioOn()) {
+                    mSetSubscriptionInProgress = false;
+                    mSetDdsRequired = true;
+                }
                 break;
 
             case EVENT_RADIO_ON:
                 ar = (AsyncResult)msg.obj;
                 subId = (Integer)ar.userObj;
                 logd("EVENT_RADIO_ON on SUB: " + subId);
-                sendDefaultSubsInfo();
+                mRadioOn[subId] = true;
+                if (isAllRadioOn()) {
+                   sendDefaultSubsInfo();
+                }
                 break;
 
             case EVENT_CARD_INFO_AVAILABLE:
@@ -581,6 +589,10 @@
      * @param ar
      */
     private void processCleanupDataConnectionDone(Integer subId) {
+		if (!mRadioOn[subId]) {
+           logd("processCleanupDataConnectionDone: Radio Not Available on subId = " + subId);
+           return;
+        }
         // Cleanup data connection is done!  Start processing the
         // pending deactivate requests now.
         mDataActive = false;
@@ -598,6 +610,11 @@
         boolean isSubReady = mCurrentSubscriptions.get(sub).subReady;
         logd("processSubscriptionStatusChanged sub = " + subId
                 + " actStatus = " + actStatus);
+		
+		if (!mRadioOn[subId]) {
+           logd("processSubscriptionStatusChanged: Radio Not Available on subId = " + subId);
+           return;
+        }
 
         if ((isSubReady == true && actStatus == SUB_STATUS_ACTIVATED) ||
                 (isSubReady == false && actStatus == SUB_STATUS_DEACTIVATED)) {
@@ -661,6 +678,12 @@
         String cause = null;
         SubscriptionStatus subStatus = SubscriptionStatus.SUB_INVALID;
         Subscription currentSub = null;
+		
+		if (!mRadioOn[setSubParam.subId]) {
+           logd("processSetUiccSubscriptionDone: Radio Not Available on subId = "
+                + setSubParam.subId);
+           return;
+        }
 
         if (setSubParam.appType.equals("GLOBAL") &&
                 (setSubParam.subStatus == SubscriptionStatus.SUB_ACTIVATE)) {
@@ -1000,6 +1023,10 @@
      * Handles EVENT_ALL_CARDS_INFO_AVAILABLE.
      */
     private void processAllCardsInfoAvailable() {
+		if (!isAllRadioOn()) {
+           logd("processAllCardsInfoAvailable: Radio Not Available ");
+           return;
+        }
         int availableCards = 0;
         mAllCardsStatusAvailable = true;
 
@@ -1028,6 +1055,10 @@
      * Handles EVENT_PROCESS_AVAILABLE_CARDS
      */
     private void processAvailableCards() {
+		 if (!isAllRadioOn()) {
+           logd("processAvailableCards: Radio Not Available ");
+           return;
+        }
         if (mSetSubscriptionInProgress) {
            logd("processAvailableCards: set subscription in progress!!");
            return;
@@ -1143,6 +1174,11 @@
      */
     private void processCardInfoAvailable(AsyncResult ar) {
         Integer cardIndex = (Integer)ar.userObj;
+		
+		 if (!mRadioOn[cardIndex]) {
+           logd("processCardInfoAvailable: Radio Not Available on cardIndex = " + cardIndex);
+           return;
+        }
 
         mCardInfoAvailable[cardIndex] = true;
 
@@ -1195,6 +1231,14 @@
 
         mContext.startActivity(setSubscriptionIntent);
     }
+	
+	private boolean isAllRadioOn() {
+        boolean result = true;
+        for (boolean radioOn : mRadioOn) {
+            result = result && radioOn;
+        }
+        return result;
+    }
 
     private boolean isAllCardsInfoAvailable() {
         boolean result = true;
diff -ur CM11_loganxx/hardware/broadcom/libbt/src/userial_vendor.c CM11_loganxxP/hardware/broadcom/libbt/src/userial_vendor.c
--- CM11_loganxx/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-19 12:52:26.000000000 +0000
+++ CM11_loganxxP/hardware/broadcom/libbt/src/userial_vendor.c	2016-02-22 18:59:05.000000000 +0000
@@ -182,6 +182,10 @@
     uint8_t data_bits;
     uint16_t parity;
     uint8_t stop_bits;
+	
+	#if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+    int ldisc;
+	#endif
 
     vnd_userial.fd = -1;
 
@@ -252,6 +256,12 @@
     tcsetattr(vnd_userial.fd, TCSANOW, &vnd_userial.termios);
 
 #if (BT_WAKE_VIA_USERIAL_IOCTL==TRUE)
+	 // TODO: check for breakage on tuna (Galaxy Nexus). It defines this,
+    // but does not contain the kernel code to support it.
+    // Switch to N_BRCM_HCI line disclipline for ioctl to work
+    ldisc = 25; // N_BRCM_HCI
+    ioctl(vnd_userial.fd, TIOCSETD, &ldisc);
+
     userial_ioctl_init_bt_wake(vnd_userial.fd);
 #endif
 
diff -ur CM11_loganxx/packages/apps/Settings/res/xml/multi_sim_settings.xml CM11_loganxxP/packages/apps/Settings/res/xml/multi_sim_settings.xml
--- CM11_loganxx/packages/apps/Settings/res/xml/multi_sim_settings.xml	2016-02-19 12:52:42.000000000 +0000
+++ CM11_loganxxP/packages/apps/Settings/res/xml/multi_sim_settings.xml	2016-02-22 19:00:24.000000000 +0000
@@ -31,16 +31,6 @@
 <PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android"
         xmlns:settings="http://schemas.android.com/apk/res/com.android.settings">
 
-    <PreferenceScreen
-        android:key="config_sub"
-        android:title="@string/sel_sub_title"
-        android:summary="@string/sel_sub_summary"
-        android:persistent="false">
-        <intent android:action="android.intent.action.MAIN"
-                android:targetPackage="com.android.phone"
-                android:targetClass="com.android.phone.SetSubscription" />
-    </PreferenceScreen>
-
     <CheckBoxPreference
         android:key="tune_away"
         android:title="@string/tune_away_title"
diff -ur CM11_loganxx/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java CM11_loganxxP/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java
--- CM11_loganxx/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-19 12:52:42.000000000 +0000
+++ CM11_loganxxP/packages/apps/Settings/src/com/android/settings/MultiSimSettings.java	2016-02-22 19:01:44.000000000 +0000
@@ -101,7 +101,6 @@
     private ListPreference mVoice;
     private ListPreference mData;
     private ListPreference mSms;
-    private PreferenceScreen mConfigSub;
     private CharSequence[] entries; // Used for entries like Subscription1, Subscription2 ...
     private CharSequence[] entryValues; // Used for entryValues like 0, 1 ,2 ...
     private CharSequence[] summaries; // Used for Summaries like Aubscription1, Subscription2....
@@ -142,8 +141,6 @@
         mData.setOnPreferenceChangeListener(this);
         mSms = (ListPreference) findPreference(KEY_SMS);
         mSms.setOnPreferenceChangeListener(this);
-        mConfigSub = (PreferenceScreen) findPreference(KEY_CONFIG_SUB);
-        mConfigSub.getIntent().putExtra(CONFIG_SUB, true);
         mTuneAway = (CheckBoxPreference) findPreference(TUNE_AWAY);
         mTuneAway.setOnPreferenceChangeListener(this);
         mPrioritySub = (ListPreference) findPreference(PRIORITY_SUB);
@@ -230,14 +227,9 @@
         Log.d(TAG, "mIccCardCount = " + mIccCardCount);
 
         if (mIccCardCount == 0) {
-             mConfigSub.setEnabled(false);
-             mConfigSub.setSelectable(false);
              displayAlertDialog(getResources().getString(R.string.no_sim_info));
              configureMSimMenu(false);
         } else if (mIccCardCount == 1) {
-             //1 SIM card is present. Config sub must be accessible
-             mConfigSub.setEnabled(true);
-             mConfigSub.setSelectable(true);
              configureMSimMenu(false);
         } else if ( (mIccCardCount > 1) && (mIccCardCount <= MAX_SUBSCRIPTIONS) )  {
             configureMSimMenu(true);
@@ -591,11 +583,6 @@
                     }
 
                     break;
-                case EVENT_SUBSCRIPTION_ACTIVATED:
-                case EVENT_SUBSCRIPTION_DEACTIVATED:
-                    updateMultiSimEntriesForVoice();
-                    updateMultiSimEntriesForSms();
-                    break;
 
                 case EVENT_SET_VOICE_SUBSCRIPTION:
                     if (!mHasTuneAway) {
diff -ur CM11_loganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java CM11_loganxxP/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java
--- CM11_loganxx/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-19 12:52:45.000000000 +0000
+++ CM11_loganxxP/packages/services/Telephony/src/com/android/phone/CallFeaturesSetting.java	2016-02-22 19:03:14.000000000 +0000
@@ -60,6 +60,7 @@
 import android.provider.ContactsContract.CommonDataKinds;
 import android.provider.MediaStore;
 import android.provider.Settings;
+import android.telephony.MSimTelephonyManager;
 import android.telephony.PhoneNumberUtils;
 import android.text.TextUtils;
 import android.util.Log;
@@ -2693,10 +2694,15 @@
      * This is useful for implementing "HomeAsUp" capability for second-level Settings.
      */
     public static void goUpToTopLevelSetting(Activity activity) {
-        Intent intent = new Intent(activity, CallFeaturesSetting.class);
-        intent.setAction(Intent.ACTION_MAIN);
-        intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-        activity.startActivity(intent);
+         if (!MSimTelephonyManager.getDefault().isMultiSimEnabled()) {
+            // HACK: This doesn't work on multi-SIM (and we have multiple)
+            //       hierachy (MSimCallFeaturesSetting and MSimCallFeatureSubSetting)
+            //       so let just allow this to act like "back" button
+            Intent intent = new Intent(activity, CallFeaturesSetting.class);
+            intent.setAction(Intent.ACTION_MAIN);
+            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
+            activity.startActivity(intent);
+        }
         activity.finish();
     }
 

commit aa496769fa9d4e49bbce4f7d275f896d817b1a96
Author: Grace5921 <androidlover5842@gmail.com>
Date:   Thu Apr 21 21:12:51 2016 +0530

    patch to fix video play back in browser
    
    Change-Id: I4e6f18809bc0c8a749c12bcce7de9cb985dc4792

diff --git a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
index 1577cda..597167f 100644
--- a/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/frameworks/av/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -22,10 +22,6 @@
 #include <media/stagefright/ColorConverter.h>
 #include <media/stagefright/MediaErrors.h>
 
-#ifdef MTK_HARDWARE
-#include <mtkcolorconverter/MtkColorConverter.h>
-#endif
-
 namespace android {
 
 ColorConverter::ColorConverter(
@@ -33,18 +29,11 @@ ColorConverter::ColorConverter(
     : mSrcFormat(from),
       mDstFormat(to),
       mClip(NULL) {
-#ifdef MTK_HARDWARE
-    mMtkColorConverter = new MtkColorConverter(this);
-#endif
 }
 
 ColorConverter::~ColorConverter() {
     delete[] mClip;
     mClip = NULL;
-#ifdef MTK_HARDWARE
-    delete mMtkColorConverter;
-    mMtkColorConverter = NULL;
-#endif
 }
 
 bool ColorConverter::isValid() const {
@@ -58,11 +47,6 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
-#ifdef MTK_HARDWARE
-        case OMX_MTK_COLOR_FormatYV12:
-        case OMX_COLOR_FormatVendorMTKYUV:
-        case OMX_COLOR_FormatVendorMTKYUV_FCM:
-#endif
             return true;
 
         default:
@@ -119,11 +103,7 @@ status_t ColorConverter::convert(
 
     switch (mSrcFormat) {
         case OMX_COLOR_FormatYUV420Planar:
-#ifdef MTK_HARDWARE
-            err = mMtkColorConverter->convertYUVToRGBHW(src, dst);
-#else
             err = convertYUV420Planar(src, dst);
-#endif
             break;
 
         case OMX_COLOR_FormatCbYCrY:
@@ -142,14 +122,6 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
-#ifdef MTK_HARDWARE
-        case OMX_MTK_COLOR_FormatYV12:
-        case OMX_COLOR_FormatVendorMTKYUV:
-        case OMX_COLOR_FormatVendorMTKYUV_FCM:
-            err = mMtkColorConverter->convertYUVToRGBHW(src, dst);
-            break;
-#endif
-
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
